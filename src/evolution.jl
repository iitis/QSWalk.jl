export
  evolve_operator,
  evolve

"""
    evolve_operator(evo_gen, time)

Return an exponent of `time`×`evo_gen`. This function is useful in the case of
multiple initial states and fixed `evo_gen` and `time`, as it is faster to
compute the exponent once and use it for evolving on different initial states.

*Note:* Parameter `evo_gen` must be of type `Matrix`. For type `SparseMatrixCSC`
case different numerical approach is used. See function ```epmv``` in package
```Expokit```.

# Examples

```jldoctest
julia> H, L = [0 1; 1 0], [[0 1; 0 0], [0 0; 1 0]]
([0 1; 1 0], Array{Int64,2}[[0 1; 0 0], [0 0; 1 0]])

julia> evolve_operator(evolve_generator(H, L), 4.0)
4×4 Array{Complex{Float64},2}:
 0.499815+0.0im                0.0+0.00127256im         0.0-0.00127256im  0.500185+0.0im
      0.0+0.00127256im  0.00960957+0.0im         0.00870607+0.0im              0.0-0.00127256im
      0.0-0.00127256im  0.00870607+0.0im         0.00960957+0.0im              0.0+0.00127256im
 0.500185+0.0im
```
"""
function evolve_operator(evo_gen::Matrix{<:Number}, time::Real)
  @argumentcheck time>= 0 "Time has to be nonnegative"
  @argumentcheck size(evo_gen, 1) ==  size(evo_gen, 2) "Argument evo_gen has to be a square matrix"

  expm(time*evo_gen)
end

"""

    evolve(evo_gen, init_state, time)

    evolve(evo_gen, init_state, tpoints)

    evolve(evo_super, init_state)

Simulate the GKSL master equation according to the equation

``|result⟩⟩ = exp(time*evo_gen)|init_state⟩⟩``

where ``|⋅⟩⟩`` denotes the vectorization.

*Note:* The function returns unvectorized `result`.

The evolution can be calculated using three different approaches.

In the simplest case the function accepts matrix `evo_gen` specifying the
generator of the evolution, `init_state` describing the starting point of the
evolution, and `time` specifying the time of the evolution.

*Note:* If `evo_gen` is of type `Matrix`, the exponent is calculated using
`expm` function. If `evo_gen` is of type `SparseMatrixCSC`, `expmv` from
`Expokit.jl` is used.

Alternatively, a list of point of time (`tpoints`) can be given. Points of time
needs to be non-negative (you cannot go back in time). In this case a list of
resulting states is returned.

*Note:* It is up to the user to provide `evo_gen` and `init_state` fulfilling
the appropriate conditions. For the procedure to work correctly `evo_gen` should
be generated by `evolve_generator` function and `iniit_state` should be a proper
density matrix.

The third approach can be used if the superoperator is known. In this case
argument `evo_super` can be specified. This argument can be generated by
`evolve_operator` function. This is useful to simulate a fixed model of
evolution in the case of multiple initial states and the same time point.

# Examples

```jldoctest
julia> H, L = [0 1; 1 0], [[0 1; 0 0], [0 0; 1 0]]
(
[0 1; 1 0],

Array{Int64, 2}[
[0 1; 0 0],

[0 0; 1 0]])

julia> evolve(evolve_generator(H, L), proj(1, 2), 4.)
2×2 Array{Complex{Float64}, 2}:
 0.499815-0.0im              0.0-0.00127256im
      0.0+0.00127256im  0.500185-0.0im

julia> evolve(evolve_generator(H, L), proj(1, 2), [1., 2., 3., 4.])
4-element Array{Array{Complex{Float64}, 2}, 1}:
 Complex{Float64}[0.433203-0.0im 0.0-0.107605im; 0.0+0.107605im 0.566797-0.0im]
 Complex{Float64}[0.485766-0.0im 0.0+0.0171718im; 0.0-0.0171718im 0.514234-0.0im]
 Complex{Float64}[0.505597-0.0im 0.0+0.00261701im; 0.0-0.00261701im 0.494403-0.0im]
 Complex{Float64}[0.499815-0.0im 0.0-0.00127256im; 0.0+0.00127256im 0.500185-0.0im]

julia> ev_op = evolve_operator(evolve_generator(H, L), 4.)
4×4 Array{Complex{Float64}, 2}:
 0.499815+0.0im                0.0+0.00127256im         0.0-0.00127256im  0.500185+0.0im
      0.0+0.00127256im  0.00960957+0.0im         0.00870607+0.0im              0.0-0.00127256im
      0.0-0.00127256im  0.00870607+0.0im         0.00960957+0.0im              0.0+0.00127256im
 0.500185+0.0im                0.0-0.00127256im         0.0+0.00127256im  0.499815+0.0im

julia> evolve(ev_op, proj(1, 2))
2×2 Array{Complex{Float64}, 2}:
 0.499815+0.0im              0.0+0.00127256im
      0.0-0.00127256im  0.500185+0.0im
```
"""
function evolve(exp_evolve_generator::Matrix{<:Number},
                initial_state::SparseDenseMatrix)
  @argumentcheck size(exp_evolve_generator, 1) ==  size(exp_evolve_generator, 2) "Argument exp_evolve_generator should be square"
  @argumentcheck size(initial_state, 1) ==  size(initial_state, 2) "Initial_state should be a square matrix"
  @assert size(exp_evolve_generator, 1) ==  size(initial_state, 1)^2 "The initial state size should be square root of exp_evolve_generator size"

  unres(exp_evolve_generator*res(initial_state))
end

function evolve(evolve_generator::Matrix{<:Number},
                initial_state::SparseDenseMatrix,
                timepoint::Real)
  @argumentcheck size(evolve_generator, 1) ==  size(evolve_generator, 2) "Argument evolve_generator should be square"
  @argumentcheck size(initial_state, 1) ==  size(initial_state, 2) "Initial_state should be a square matrix"
  @assert size(evolve_generator, 1) ==  size(initial_state, 1)^2 "The initial state size should be square root of evolve_generator size"
  @argumentcheck timepoint>= 0 "Time needs to be nonnegative"

  unres(expm(timepoint*evolve_generator)*res(initial_state))
end

function evolve(evolve_generator::SparseMatrixCSC{<:Number},
                initial_state::SparseDenseMatrix,
                timepoint::Real)
  @argumentcheck size(evolve_generator, 1) ==  size(evolve_generator, 2) "Argument evolve_generator should be a square matrix"
  @argumentcheck size(initial_state, 1) ==  size(initial_state, 2) "Argument initial_state should be a square matrix"
  @assert size(evolve_generator, 1) ==  size(initial_state, 1)^2 "The initial state size should be square root of evolve_generator size"
  @argumentcheck timepoint>= 0 "Time needs to be nonnegative"
  unres(expmv(timepoint, evolve_generator, full(res(initial_state))))
end

function evolve(evolve_generator::SparseDenseMatrix,
                initial_state::SparseDenseMatrix,
                timepoints::Vector{<:Number})
  @argumentcheck size(evolve_generator, 1) ==  size(evolve_generator, 2) "evolve_generator should be a square matrix"
  @argumentcheck size(initial_state, 1) ==  size(initial_state, 2) "Argument initial_state should be a square matrix"
  @assert size(evolve_generator, 1) ==  size(initial_state, 1)^2 "The initial state size should be square root of evolve_generator size"
  @argumentcheck all(timepoints.>= 0) "All time points need to be nonnegative"

  [evolve(evolve_generator, initial_state, t) for t = timepoints]
end
